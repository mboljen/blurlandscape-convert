#!/usr/bin/env bash
#
#  Created:        Mi 2022-12-07 21:58:05 CET
#  Last Modified:  Sa 2025-12-27 11:52:14 CET
#
# blurlandscape-convert:
#   Add blurred padding to convert portrait images to landscape

# Help text
usage() {
cat << EOF
Add blur padding to convert portrait image to landscape

Usage: blurlandscape-convert [OPTION]... INFILE...

Options:
  -m, --method=VALUE     Set virtual pixel method (dither|mirror|random)
  -r, --ratio=VALUE      Set output ratio (default: none)
  -o, --out=VALUE        Set output filename suffix or directory name (default: none)
  -y, --yes              Overwrite existing files
  -h, --help             Show this help message and exit
EOF
}

# Echo error messages on STDERR
echoerr () { cat <<< "$@" 1>&2; }

# Defaults
vpixel=dither
out=
ratio=
yes=0

# Parse command line options
if ! args=$(getopt -a -o m:o:r:hy --long method:,out:,ratio:,help,yes -- "$@")
then
    echoerr "Error processing command line options"
    usage
    exit 1
fi

# Process command line options
eval set -- "$args"
while :
do
    case $1 in
      -m | --method)  vpixel=$2 ; shift 2 ;;
      -o | --out)     out=$2    ; shift 2 ;;
      -r | --ratio)   ratio=$2  ; shift 2 ;;
      -y | --yes)     yes=1     ; shift   ;;
      -h | --help)    usage     ; shift   ; exit 0 ;;
      # -- means the end of the arguments; drop this, and break out of the while loop
      --) shift; break ;;
       *) echoerr "Unsupported option: $1"; usage ; shift; exit 1 ;;
    esac
done


# Check number of arguments
if [ "$#" -eq 0 ]
then
    echo "$0 requires at least 1 argument"
    usage
    exit 1
fi

# Check output variable
if [ -z "$out" ]
then

    # Not defined, use default filename suffix and current directory
    dir=$(pwd)
    suffix='blsc'
    echoerr "Using default output filename suffix: $suffix"

elif [ -d "$out" ]
then

    # Defined, output variable is an existing directory"
    dir=$out
    suffix=

elif [[ "$out" == *\/* ]] || [[ "$out" == *\\* ]]
then

    # Defined, output variable contains slashes, use it as directory name"
    dir=$out
    suffix=

else

    #echo "ok, $out is suffix, use current directory as output directory"
    dir=$(pwd)
    suffix=$out

fi

# Check ratio tag
if [ -n "$ratio" ]
then

    # Replace aliases by corresponding ratio
    if   [[ "$ratio" == '16:9'  ]]; then ratio=1.7778
    elif [[ "$ratio" == '16:10' ]]; then ratio=1.6000
    elif [[ "$ratio" == '4:3'   ]]; then ratio=1.3333
    elif [[ "$ratio" == '5:4'   ]]; then ratio=1.2500
    elif [[ "$ratio" == '2:3'   ]]; then ratio=0.6666
    elif [[ "$ratio" == '10:16' ]]; then ratio=0.6250
    elif [[ "$ratio" == '9:16'  ]]; then ratio=0.5625
    fi
fi

# Loop over input files
while [ $# -gt 0 ]
do

    # Grep next argument
    srcfile=$1
    shift

    # Check if argument is valid file
    if [ ! -f "$srcfile" ]
    then
        echoerr "$srcfile is not a valid faile, skipped"
        continue
    fi

    # Get orientation
    orientation=$(identify -format '%[exif:orientation]' $srcfile)

    # Handle vertical disply correction by EXIF orientation flag
    if (( orientation > 4 ))
    then

        # https://stackoverflow.com/questions/9371273
        w=$(identify -format "%h" $srcfile)
        h=$(identify -format "%w" $srcfile)

    else

        # Get height and width
        w=$(identify -format "%w" $srcfile)
        h=$(identify -format "%h" $srcfile)

    fi

    # Check dimensions
    if ! [[ $w =~ ^[0-9]+$ ]] || ! [[ $h =~ ^[0-9]+$ ]]
    then

        # Skip image if dimensions are not available
        echoerr "Cannot get size"
        continue

    else

        # Detect given ratio
        r=$(bc -l <<< "$w/$h")

        # Consider ratio if given
        if [ -n "$ratio" ]
        then

            # Use given ratio
            w1=$(bc -l <<< "scale=0; $h*$ratio/1")
            h1=$h

        elif (( h > w ))
        then

            # Flip height to weight using given ratio
            h1=$w
            w1=$h

        else

            # No ratio given, image is landscape, nothing to do
            echoerr "Input already landscape, no ratio given, skipped"
            continue

        fi

        # Process portrait images only
        echo -n "Processing $srcfile ... "

        # Create output directory unless existing
        mkdir -p "$dir"

        # Assemble name of output file
        tmp=$(basename -- "$srcfile")
        if [ -z "$suffix" ]
        then
            newfile="$dir/${tmp%.*}.${tmp##*.}"
        else
            newfile="$dir/${tmp%.*}-$suffix.${tmp##*.}"
        fi

        # Skip conversion if output file exists and no permission to overwrite
        if [ -f "$newfile" ]
        then
            if [ "$yes" -ne 0 ]
            then
                # Remove existing file
                rm "$newfile"
            else
                # Skip file
                echoerr "Outfile $newfile already exists, skipped"
                continue
            fi
        fi

        # Compare required ratio with given ratio
        if [ 1 -eq "$(echo "$w/$h < $r" | bc)" ]
        then

            # Invoke Magick convert (portrait), add background left/right
            convert "$srcfile" -auto-orient \
                 \( -clone 0 -virtual-pixel "$vpixel" \
                    -set option:distort:viewport "${w1}x${h1}+${w1}+0" \
                    -filter point -distort SRT 0 +repage -blur 0x5 \) \
                 +swap -gravity center -resize "x${h1}" -compose over -composite \
                 -resize "${w1}x" \
                 "$newfile"

        else

            # Invoke Magick convert (landscape), add background top/bottom
            convert "$srcfile" -auto-orient \
                 \( -clone 0 -virtual-pixel "$vpixel" \
                    -set option:distort:viewport "${w1}x${h1}+0+${h1}" \
                    -filter point -distort SRT 0 +repage -blur 0x5 \) \
                 +swap -gravity center -resize "${w1}x" -compose over -composite \
                 -resize "x${h1}" \
                 "$newfile"

        fi

        # Success message
        printf "ok (%d kB written)\n" $(echo "$(wc -c $newfile | awk '{print $1}') / 1024" | bc)
    fi
done
